{"version":3,"sources":["queryLight.ts"],"names":["qlWrapper","constructor","elements","this","_entries","collection","setCollection","value","Array","forEach","i","Node","pushElement","unambiguityRequire","get","Error","child","input","q","addClass","each","classList","add","removeClass","remove","toggleClass","hasClass","every","contains","on","eventName","callback","addEventListener","el","call","insertBefore","sibling","parent","insertAfter","nextSibling","next","insert","appendChild","insertFirst","firstElement","firstElementChild","replace","newElement","replaceWith","clear","innerHTML","index","wrap","topOffset","offsetTop","text","innerText","html","val","count","length","selector","parentElement","matches","prev","previousElementSibling","nextElementSibling","elems","HTMLFormElement","formData","_a","reduce","carry","name","Object","assign","equalTo","element","isEqualNode","inCollection","some","push","Function","document","Document","selected","querySelectorAll","HTMLElement","Window","Proxy","target","prop","receiver","Reflect","gotten","bind","set"],"mappings":"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","file":"queryLight.min.js","sourcesContent":["/**\n * @fileOverview Lightweight module for DOM manipulations\n *\n * @author Alexandr Shamanin (slpAkkie)\n * @version 2.0.1\n */\n\n\n\n\n\n//\ninterface qlWrapper { [key: string]: any }\n//\ntype qlElement = HTMLElement | HTMLDocument\n//\ntype qlCommonElement = HTMLElement | qlWrapper\n//\ntype qlCollection = Array<qlElement>\n//\ntype qlInput = string | Array<Node> | qlElement | qlWrapper\n\n\n\n\n\n//\nclass qlWrapper {\n\n  /**\n   * @property {qlCollection}\n   */\n  _entries: qlCollection\n\n  get collection() { return this._entries }\n\n  setCollection(value: Array<qlInput>) {\n    if (value instanceof Array) {\n      value.forEach(i => {\n        if (typeof i === 'string' || i instanceof Node || i instanceof qlWrapper)\n          this.pushElement(i instanceof qlWrapper ? i.unambiguityRequire().get() : i)\n\n        throw new Error('qlWrapper может содержать только DOM узлы')\n      })\n\n      return this\n    }\n\n    throw new Error('Коллекция должна быть массивом')\n  }\n\n  constructor(elements) { this._entries = elements }\n\n  /**\n   * TODO: Update to find in several elements\n   *\n   * @param {qlInput} input\n   * @returns {qlWrapper}\n   */\n  child(input: qlInput): qlWrapper { return q(input, this) }\n\n  /**\n   * @param {string} value\n   * @returns {qlWrapper}\n   */\n  addClass(value: string): qlWrapper { return this.each(i => i.classList.add(value)) }\n\n  /**\n   * @param {string} value\n   * @returns {qlWrapper}\n   */\n  removeClass(value: string): qlWrapper { return this.each(i => i.classList.remove(value)) }\n\n  /**\n   * @param {string} value\n   * @returns {qlWrapper}\n   */\n  toggleClass(value: string): qlWrapper { return this.each(i => i.hasClass(value) ? i.removeClass(value) : i.addClass(value)) }\n\n  /**\n   * @param {string} value\n   * @returns {qlWrapper}\n   */\n  hasClass(value: string): boolean { return this.collection.every(i => (<HTMLElement>i).classList.contains(value)) }\n\n  /**\n   * @param {string} eventName\n   * @param {Function} callback\n   * @returns {qlWrapper}\n   */\n  on(eventName, callback): qlWrapper { return this.each(i => (<HTMLElement>i).addEventListener(eventName, callback)) }\n\n  /**\n   * @param {Function} callback\n   * @returns {qlWrapper}\n   */\n  each(callback: Function): qlWrapper {\n    this.collection.forEach((el, i) => callback.call(q(el), q(el), i))\n\n    return this\n  }\n\n  /**\n   * @param {qlCommonElement} sibling\n   * @returns {qlCommonElement}\n   */\n  insertBefore(sibling: qlCommonElement): qlCommonElement {\n    sibling = q(sibling)\n    sibling.each(i => this.parent().get().insertBefore(i.get(), <Node>this.get()))\n\n    return sibling\n  }\n\n  /**\n   * @param {qlCommonElement} sibling\n   * @returns {qlCommonElement}\n   */\n  insertAfter(sibling: qlCommonElement): qlCommonElement {\n    let nextSibling = this.next()\n\n    return nextSibling ? nextSibling.insertBefore(q(sibling)) : this.parent().insert(q(sibling))\n  }\n\n  /**\n   * @param {qlCommonElement} sibling\n   * @returns {qlCommonElement}\n   */\n  insert(child: qlCommonElement): qlCommonElement {\n    child = q(child)\n    child.each(i => this.unambiguityRequire().appendChild(i.get()))\n\n    return child\n  }\n\n  /**\n   * @param {qlCommonElement} sibling\n   * @returns {qlCommonElement}\n   */\n  insertFirst(child: qlCommonElement): qlCommonElement {\n    let firstElement = q(this.firstElementChild)\n\n    return firstElement ? firstElement.insertBefore(child) : this.insert(child)\n  }\n\n  /**\n   * @param {qlCommonElement} newElement\n   * @returns {qlCommonElement}\n   */\n  replace(newElement: qlCommonElement): qlCommonElement { return this.replaceWith(q(newElement).get()) || newElement }\n\n  /**\n   * @returns {qlWrapper}\n   */\n  clear(): qlWrapper { return this.each(el => el.innerHTML = '') }\n\n  /**\n   * @param {number} index\n   * @param {boolean} wrap\n   * @returns {qlElement | qlWrapper}\n   */\n  get(index: number = 0, wrap: boolean = false): qlElement | qlWrapper { return wrap ? q(this.collection[index]) : this.collection[index] || null }\n\n  /**\n   * @returns {number}\n   */\n  topOffset(): number { return this.offsetTop }\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  text(value: string = null): string { return typeof value === 'string' && this.each(i => i.innerText = value) ? value : this.innerText }\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  html(value: string = null): string { return typeof value === 'string' && this.each(i => i.innerHTML = value) ? value : this.innerHTML }\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  val(value: string = null): string { return typeof value === 'string' && this.each(i => i.value = value) ? value : this.value }\n\n  /**\n   * @returns {number}\n   */\n  count(): number { return this.collection.length }\n\n  /**\n   * @param {string} selector\n   * @returns {qlWrapper}\n   */\n  parent(selector: string = null): qlWrapper {\n    let parent: qlWrapper = this.parentElement\n    if (parent.matches(':root')) return null\n\n    return !selector || parent.matches(selector) ? parent : parent.parent(selector)\n  }\n\n  /**\n   * @returns {qlWrapper}\n   */\n  prev(): qlWrapper { return this.previousElementSibling }\n\n  /**\n   * @returns {qlWrapper}\n   */\n  next(): qlWrapper { return this.nextElementSibling }\n\n  /**\n   * @returns {qlWrapper}\n   */\n  elems(): qlWrapper { return this.get() instanceof HTMLFormElement ? q([...this.elements]) : null }\n\n  /**\n   * @returns {Object}\n   */\n  formData(): Object { return (<Array<HTMLInputElement>>this.elems()?.collection || []).reduce((carry, i) => i.name ? Object.assign(carry, { [i.name]: i.value }) : carry, {}) }\n\n  /**\n   * @param {qlCommonElement} element\n   * @returns {boolean}\n   */\n  equalTo(element: qlCommonElement): boolean { return this.isEqualNode((element = q(element)).unambiguityRequire().get()) }\n\n  /**\n   * @param {qlCommonElement} element\n   * @returns {boolean}\n   */\n  inCollection(element: qlCommonElement): boolean { return this.collection.some(i => q(i).equalTo(element)) }\n\n\n\n  /**\n   * @throws {Error}\n   * @returns {qlWrapper}\n   */\n  unambiguityRequire(): qlWrapper {\n    if (this.count() > 1) throw new Error(`Вызов не однозначен, в коллекции ${this.count()} элементов`)\n\n    return this\n  }\n\n  /**\n   * @param {qlInput} element\n   * @returns {qlWrapper}\n   */\n  pushElement(...elements: qlInput[]): qlWrapper {\n    elements.forEach(i => { if (i = q(i)) this.inCollection(i) || this._entries.push(<qlElement>i.get()) })\n\n    return this\n  }\n\n}\n\n\n\n\n\n/**\n * @param {qlInput | Function} input\n * @param {qlInput} parent\n * @returns {qlWrapper}\n */\nexport default function q(input: qlInput | Function, parent?: qlInput): qlWrapper {\n\n  if (input instanceof Function) return q(document).on('DOMContentLoaded', input)\n  else if (input instanceof qlWrapper) return input\n\n  if (!(input instanceof Document)) {\n    parent = q(parent || document)\n    if (parent.count() !== 1) throw new Error('There are several elements into the qlWrapper')\n    parent = <qlElement>parent.get()\n  }\n\n\n\n  let selected = []\n\n  if (typeof input === 'string') selected = [...(<qlElement>parent).querySelectorAll(input)]\n  else if (input instanceof HTMLElement || input instanceof Window || input instanceof Document) selected = [<qlElement>input]\n  else if (input instanceof Array) selected = input\n\n  if (selected.length === 0) return null\n\n\n\n  return new Proxy(new qlWrapper(selected), {\n    get(target, prop, receiver) {\n      if (prop in target) return Reflect.get(target, prop, receiver)\n\n      let gotten = Reflect.get(target.unambiguityRequire().get(), prop)\n\n      return typeof gotten === 'function'\n        ? gotten.bind(target.get())\n        : gotten instanceof Node ? q(<qlInput>gotten) : gotten\n    },\n\n    set(target, name, val) {\n      return name in target\n        ? Reflect.set(target, name, val)\n        : Reflect.set(target.unambiguityRequire().get(), name, val)\n    }\n  })\n\n}\n"]}